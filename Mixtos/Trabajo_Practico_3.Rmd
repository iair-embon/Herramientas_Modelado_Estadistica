---
title: "Trabajo Practico 3"
author: "Alejandro Ramos Usaj y Iair Embon"
date: '2022-07-07'
output: html_document
---
Cargo librerias que vamos a utilizar
```{r}
library(tidyverse)
```

Cargo los datos
```{r}
root <- rprojroot::is_rstudio_project
basename(getwd())

titles_train <- read.csv(root$find_file("Mixtos/titles_train.csv"))
credits_train <- read.csv(root$find_file("Mixtos/credits_train.csv"))
```

# 1

Primero tengo que normalizar la base de datos de entrenamiento que tiene muchos generos metidos en una sola columna. Queremos que cada genero sea una sola columna y que tenga un valor de 1 indicando si esa fila pertenece a ese genero y 0 de otra manera. 

Para esto en primer lugar eliminamos de las filas con el genero de las peliculas a todos los caracteres que no corresponden con letras o comas. De esta manera deberiamos quedarnos con una estructura que sea "genero1,genero2, ...,generoN". De ahora en mas comprobamos el procedimiento extrayendo 10 datos aleatoriamente del dataframe resultante posterior a la manipulacion.

```{r}
titles_train %>% 
  mutate(genres = str_replace_all(genres,"[^A-Za-z,]","")) %>%
  slice_sample(n = 10) %>%
  pull(genres)
```

A continuacion usamos la funcion de `separate_rows` para separar los generos por coma de manera que cada uno sea una fila nueva. 


```{r}
titles_train %>% 
  mutate(genres = str_replace_all(genres,"[^A-Za-z,]","")) %>% 
  separate_rows(genres, sep = ',') %>% 
  slice_sample(n = 10) %>%
  select(title, genres)
```

Proximamente generamos una columna dummy nueva con todos valores de 1 para usar como valores cuando pasemos el dataframe a formato wide. Asimismo filtramos aquellas filas que quedaron sin ningun genero (sin caracteres) como consecuencia de la funcion `separate_rows`.

```{r}
titles_train %>% 
  mutate(genres = str_replace_all(genres,"[^A-Za-z,]","")) %>% 
  separate_rows(genres, sep = ',') %>% 
  mutate(dummy = 1) %>% filter(genres != '') %>% 
  slice_sample(n = 10) %>%
  select(title, genres, dummy)
```

Por ultimo vamos a usar la funcion `pivor_wider` para convertir el dataframe de formato long como esta ahora (con filas repetidas para distintos titulos) a formato wide donde cada genero corresponda a una columna con valores dados por la columna dummy. 

```{r}
titles_train %>% 
  mutate(genres = str_replace_all(genres,"[^A-Za-z,]","")) %>% 
  separate_rows(genres, sep = ',') %>% 
  mutate(dummy = 1) %>% filter(genres != '') %>% 
  pivot_wider(names_from = genres, values_from = dummy) %>% 
  slice_sample(n = 10) %>%
  select(title, comedy:sport)
```

Finalmente reemplazamos aquellos valores que quedaron como `NA` con un 0 indicando que ese genero no pertenece a ese titulo y escribimos todo el procedimiento anterior en un solo bloque. 

```{r}
titles_train_trans <- titles_train %>% 
  mutate(genres = str_replace_all(genres,"[^A-Za-z,]","")) %>% 
  separate_rows(genres, sep = ',') %>% 
  mutate(dummy = 1) %>% filter(genres != '') %>% 
  pivot_wider(names_from = genres, values_from = dummy) %>% 
  mutate(across(comedy:sport, ~ replace_na(.x, 0))) 
```

Por ultimo podria ser interesante tener una columna que cuente cuantos generos tiene un determinado titulo y para esto vamos a agregar una columna nueva sumando los 1 para todas las columnas correspondientes a los distintos generos. 

```{r}
titles_train_trans <- titles_train_trans %>% mutate(cant_genres = rowSums(across(comedy:sport)))
```

Solo falta normalizar la columna correspondiente a los paises encargados de la produccion. Sin embargo hay demasiados paises involucrados, muchos mas que en el caso de los generos lo que nos dejaria con demasiadas columnas con muchos valores en 0. 

```{r}
titles_train_trans <-  titles_train_trans %>% 
  mutate(production_countries = str_replace_all(production_countries,"[^A-Za-z,]","")) %>% 
  separate_rows(production_countries, sep = ',') %>% 
  distinct(id, .keep_all = T)
```

Si quisieramos ir por la otra via podemos comprobar tambien la frecuencia de cada pais para ver que tan concentrados estan los datos alrededor de determinados paises. 

```{r}
titles_train %>% 
  mutate(production_countries = str_replace_all(production_countries,"[^A-Za-z,]","")) %>% 
  separate_rows(production_countries, sep = ',') %>% 
  filter(production_countries != '') %>%
  count(production_countries) %>% 
  ggplot(aes(x = production_countries, y = n)) +
  geom_col() + theme(axis.text.x = element_blank())
```

Vemos que hay unos pocos paises que concentrar la mayoria de los datos. Generamos entonces 10 factores y el resto quedan como "otros".

```{r}
titles_train_countries_wide <- titles_train_trans %>%
  mutate(production_countries = str_replace_all(production_countries,"[^A-Za-z,]","")) %>% 
  separate_rows(production_countries, sep = ',') %>% 
  filter(production_countries != '') %>%
  mutate(production_countries = fct_lump_n(production_countries, 10, other_level = "Otros"))
```

Podemos comprobar de nuevo como queda la distribucion de factores posterior a esta manipulacion.

```{r}
titles_train_countries_wide %>% count(production_countries) %>% 
  ggplot(aes(x = production_countries, y = n)) +
  geom_col()
```
El factor 'Otros' recopila bastantes valores. Puede que mas adelante sea mas conveniente crear una sola columna que sea "US" u "Otros" para condensar mejor la distribucion pero ahora procedemos de esta manera. 

Ahora si podemos replicar el abordaje que seguimos con el genero y convertir cada factor en una columna separada. Lo unico que hay que hacer es eliminar los duplicados porque hay peliculas que titulos repetidos dado que tenian distintos paises asignados pero estos distintos paises se convirtieron en la misma categoria dejando a las filas como repetidas. 

```{r}
titles_train_countries_wide <- titles_train_trans %>% mutate(dummy = 1) %>% 
  distinct() %>%
  pivot_wider(names_from = production_countries, values_from = dummy) %>% 
  mutate(
    across(any_of(levels(titles_train_trans$production_countries)), ~ replace_na(.x, 0))
    )
```


## a)

```{r}
titles_train %>% 
  mutate(genres = str_replace_all(genres,"[^A-Za-z,]","")) %>% 
  separate_rows(genres, sep = ',') %>% filter(genres != '') %>%
  ggplot(
    aes(x = genres, y = imdb_score)
  ) +
    geom_boxplot()
```




Exploro los datos. Sigo la lista de recomendaciones y agregamos otras exploraciones
```{r}
str(titles_train)
str(credits_train)

### a

# creo una funcion que me preprocese el vector con characteres
prepro_character_vector <- function(vec){
  # saco corchetes
  vec_sin_corchetes <- gsub("\\[|\\]", "", vec)
  # separo por coma
  vec_csv <- strsplit(vec_sin_corchetes, split = ",")
  # unlist
  vec_unlist <- unlist(vec_csv)
  # saco apostrofes
  vec_sin_apostrofes <- gsub("'", "", vec_unlist)
  # saco el espacio inicial de algunos vectores
  vec_sin_espacio <- gsub(" ", "", vec_sin_apostrofes)
  # busco los valores unicos
  vec_final <- unique(vec_sin_espacio)
  return(vec_final)
  }

generos <- prepro_character_vector(titles_train$genres)

puntaje_promedio <- rep(0, length(generos))

for (i in 1:nrow(titles_train)) {
  is_in_genero <- generos %in% prepro_character_vector(titles_train$genres[i])
  index_genero <- which(is_in_genero ==T)
  for (j in 1:length(index_genero)) {
    puntaje_promedio[index_genero[j]] <- puntaje_promedio[index_genero[j]] + titles_train$imdb_score[i]
  }
} # tira un error, hasta i =  a 3 lo probe y funciona bien, en algun momento se rompe


# plotear
ggplot(titles_train, aes(x=genres, y=imdb_score, fill=genres)) + 
  geom_violin()

```

En el punto 4 fijar un parametro de penalizacion
